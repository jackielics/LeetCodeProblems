# Illustration
![image.png](https://pic.leetcode.cn/1689235654-DLXgiw-image.png)
![Untitled.png](https://pic.leetcode.cn/1689236048-zWIgKL-Untitled.png)

# Intuition
1-DP, similiar to $Climbing Stairs$

# Approach
1-DP

# Complexity
- Time complexity:
O(n)

- Space complexity:
O(1)

# Code
```python
	def numDecodings(self, s: str) -> int:
		'''
		My Solution: O(1) 1-DP
		'''
		if s[0] == '0':
			return 0 
		elif len(s) == 1:
			return 1
		# Initialize: pprev, prev [res, last_char]
		pp, p = [1, str()], [1, s[0]]
		for c in s[1:]:
			cur = 0 # current accumulating num of decode 
			# pp to cur: 2 digits s[i-1] + s[i]]
			if 10 <= int(p[1] + c) <= 26: # [10, 26]
				cur += pp[0] # connect 
			# p to cur: 1 digit s[i]
			if 1 <= int(c) <= 9: # [1, 10]
				cur += p[0] # connect 
			# move pointers
			pp = p
			p = [cur, c]

		return cur

	def numDecodings1(self, s: str) -> int:
		if s[0] == '0':
			return 0
		elif len(s) == 1:
			return 1

		dp = [0] * (len(s) + 1)
		dp[0] = dp[1] = 1
		# dp[1] = 
		for i in range(2, len(s)+1):
			# + dp[i-2]
			if 10 <= int(s[i - 2] + s[i-1]) <= 26:
				dp[i] += dp[i-2]
			if int(s[i - 1]) != 0:
				dp[i] += dp[i-1]
			if not dp[i]:
				return 0
			# + dp[i-1]
		return dp[-1]

```