![image.png](https://pic.leetcode.cn/1696907652-MSDeRo-image.png)

# Intuition
1-Dynamic Programming or Binary Search

# Approach
1-DP or Binary Search

# Complexity
- Time complexity:
${O(NlogN)}$

- Space complexity:
${O(N)}$

# Code
```python
class Solution:
    def lengthOfLIS0(self, nums: [int]) -> int:
		'''Binary Search'''
		increase = [0] * len(nums)
		res = 0 # max length of increasing subquence
		for num in nums:
			l, r = 0, res
			while l < r:
				m = (l + r) // 2
				if num > increase[m]:
					l = m + 1
				else: # num >= increase[m]
					r = m # [r] is the last (increase[m] <= num)
			increase[l] = num # num > increase[:l] strictly increase
			# if r(index, start from 0) == res(length, start from 1) 
			if r == res: # no increase[i] <= num
				res += 1
		return res

	def lengthOfLIS1(self, nums: List[int]) -> int:
		'''1-DP: Consider nums[i] as min in LIS'''
		res = 1 # max length of Longest-Increasing-Sequence
		DP = [1] * len(nums) # initial length of Longest-Increasing-Sequence

		for i in range(len(nums)): # iterate
			for j in range(i): # [0, i-1] -> i
				if nums[i] > nums[j]: # Strictly increasing
					DP[i] = max(DP[i], 1 + DP[j])
					res = max(res, DP[i])
		return res

	def lengthOfLIS2(self, nums: List[int]) -> int:
		'''Reversed 1-DP: Consider nums[i] as max in LIS'''
		res = 1 # max length of Longest-Increasing-Sequence
		DP = [1] * len(nums) # initial length of Longest-Increasing-Sequence

		for i in range(len(nums) - 1, -1, -1): # reversely iterate
			for j in range(i, len(nums)): # forwardly  iterate
				if nums[i] < nums[j]: # inherit LIS
					DP[i] = max(DP[i], 1 + DP[j])
					res = max(res, DP[i])

		return res
```